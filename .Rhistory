lambda[which.min(gcv)]
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
plot(abscissa,Xobs0,xlab="t",ylab="observed data")
t_ax <- as.matrix(1:1600)/1600
range(t_ax)
setwd("D:/Poli/Corsi/BAYESIAN/Proj/Functional-BNP-clustering")
load("data_extraction.RData")
# extract only one componet per patient
my_data = f.data$ausxSL
curves <- my_data$data
t_ax <- as.matrix(1:1600)/1600 # YOOO
n <- dim(curves)[1]
m <- 4
#nbasis_ <- 300
m <- 4
basis = create.bspline.basis(rangeval=c(1,1600),
nbasis = 60,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
setwd("D:/Poli/Corsi/BAYESIAN/Proj/Functional-BNP-clustering")
load("data_extraction.RData")
# extract only one componet per patient
my_data = f.data$ausxSL
curves <- my_data$data
t_ax <- as.matrix(1:1600)/1600 # YOOO
n <- dim(curves)[1]
m <- 4
#nbasis_ <- 300
m <- 4
basis = create.bspline.basis(rangeval=c(1,1600),
nbasis = 60,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
basis = create.bspline.basis(rangeval=range(t_ax),
nbasis = 60,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
lambda = 10^seq(-20,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
lambda = 10^seq(-50,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
lambda[which.min(gcv)]
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
basis = create.bspline.basis(rangeval=range(t_ax),
nbasis = 600,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves, 600 basis functions")
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves, 600 basis functions")
t_ax <- as.matrix(1:1600)# YOOO
n <- dim(curves)[1]
m <- 4
#nbasis_ <- 300
m <- 4
basis = create.bspline.basis(rangeval=range(t_ax),
nbasis = 60,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves, 600 basis functions")
t_ax <- as.matrix(1:1600)/1600 # YOOO
n <- dim(curves)[1]
m <- 4
#nbasis_ <- 300
m <- 4
basis = create.bspline.basis(rangeval=range(t_ax),
nbasis = 60,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves, 600 basis functions")
basis = create.bspline.basis(rangeval=range(t_ax),
nbasis = 10,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves, 600 basis functions")
basis = create.bspline.basis(rangeval=range(t_ax),
nbasis = 20,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves, 600 basis functions")
?create.bspline.basis
length(t_ax[((0:50)*2)+1])
length(t_ax[((0:50)*2)])
my_data = f.data$ausxSL
curves <- my_data$data
t_ax <- as.matrix(1:1600)/1600 # YOOO
n <- dim(curves)[1]
m <- 4
#nbasis_ <- 300
m <- 4
basis = create.bspline.basis(rangeval=range(t_ax),
breaks = t_ax[((0:50)*2)] # 50 breakpoints
#nbasis = 20,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves, 600 basis functions")
length(t_ax[((0:100)*2)])
#nbasis_ <- 300
m <- 4
basis = create.bspline.basis(rangeval=range(t_ax),
breaks = t_ax[((0:100)*2)] # 100 breakpoints
#nbasis = 20,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
basis = create.bspline.basis(rangeval=range(t_ax),
breaks = t_ax[((0:800)*2)] # 100 breakpoints
#nbasis = 20,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
#nbasis_ <- 300
m <- 4
basis = create.bspline.basis(rangeval=range(t_ax),
breaks = t_ax[((0:1600)*2)] # 100 breakpoints
#nbasis = 20,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
length(t_ax[((0:1600)*2)])
breaks = t_ax[((0:1600)*2)] #
range(breaks)
t_ax[((0:1600)*2)]
basis = create.bspline.basis(rangeval=range(t_ax),
breaks = t_ax, # 100 breakpoints
#nbasis = 20,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
basis = create.bspline.basis(rangeval=range(t_ax),
breaks = t_ax[seq(1,1600,by=4)], # 100 breakpoints
#nbasis = 20,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
# lambda = 1e3
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=1e3)
smoothedz = smooth.basis(t_ax, t(curves), functionalPar)
y_hat = t(eval.fd(t_ax, smoothedz$fd, Lfd=0))
# smoothed data
x11()
matplot(t_ax, t(y_hat), type = 'l', main = 'Smoothed Data - 30 basis functions', ylim = c(-250,250))
setwd("D:/Poli/Corsi/BAYESIAN/Proj/Functional-BNP-clustering")
load("data_extraction.RData")
# extract only one componet per patient
my_data = f.data$ausxSL
curves <- my_data$data
t_ax <- as.matrix(1:1600)
n <- dim(curves)[1]
m <- 4
basis = create.bspline.basis(rangeval=c(1,1600),
nbasis = 30,
norder=m)
lambda = 10^seq(-5,5)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
# lambda = 1e3
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=1e3)
smoothedz = smooth.basis(t_ax, t(curves), functionalPar)
y_hat = t(eval.fd(t_ax, smoothedz$fd, Lfd=0))
# smoothed data
x11()
matplot(t_ax, t(y_hat), type = 'l', main = 'Smoothed Data - 30 basis functions', ylim = c(-250,250))
nbasis_ <- 20
basis = create.bspline.basis(rangeval=range(t_ax), # 400 breakpoints
nbasis = nbasis,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
lambda = 10^seq(-20,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
lambda = 10^seq(-5,30)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
t_ax <- as.matrix(1:1600)/1600 # YOOO
n <- dim(curves)[1]
m <- 4
nbasis_ <- 20
basis = create.bspline.basis(rangeval=range(t_ax), # 400 breakpoints
nbasis = nbasis,
norder=m)
lambda = 10^seq(-5,30)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
my_data = f.data$ausxSL
curves <- my_data$data
t_ax <- as.matrix(1:1600)/1600 # YOOO
n <- dim(curves)[1]
m <- 4
nbasis_ <- 20
basis = create.bspline.basis(rangeval=range(t_ax), # 400 breakpoints
nbasis = nbasis,
norder=m)
lambda = 10^seq(-5,30)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
range(t_ax)
rm(list=ls())
setwd("D:/Poli/Corsi/BAYESIAN/Proj/Functional-BNP-clustering")
load("data_extraction.RData")
# extract only one componet per patient
my_data = f.data$ausxSL
curves <- my_data$data
t_ax <- as.matrix(1:1600)/1600 # YOOO
n <- dim(curves)[1]
m <- 4
nbasis_ <- 20
basis = create.bspline.basis(rangeval=range(t_ax), # 400 breakpoints
nbasis = nbasis,
norder=m)
lambda = 10^seq(-5,30)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
basis = create.bspline.basis(rangeval=range(t_ax), # 400 breakpoints
nbasis = nbasis,
norder=m)
nbasis <- 20
basis = create.bspline.basis(rangeval=range(t_ax), # 400 breakpoints
nbasis = nbasis,
norder=m)
lambda = 10^seq(-5,30)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
nbasis <- 10
basis = create.bspline.basis(rangeval=range(t_ax), # 400 breakpoints
nbasis = nbasis,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
# generate a basis
basis = create.bspline.basis(rangeval=range(t_ax), # 400 breakpoints
nbasis = nbasis,
norder=m)
nbasis <- 100
# generate a basis
basis = create.bspline.basis(rangeval=range(t_ax), # 400 breakpoints
nbasis = nbasis,
norder=m)
lambda = 10^seq(-10,10)
gcv=matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
n
# generate a basis
basis <- create.bspline.basis(rangeval=range(t_ax),
nbasis = nbasis,
norder=m)
lambda <- 10^seq(-10,10)
gcv <- matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
setwd("D:/Poli/Corsi/BAYESIAN/Proj/Functional-BNP-clustering")
load("data_extraction.RData")
#choose one component
my_data<-f.data$ausxSL
setwd('C:/Users/edoar/Desktop/Bayesian statistics/Project/code/Functional-BNP-clustering')
time<-1:1600
X<-my_data$data
## 4th order spline
#create basis
# Set parameters
m <- 4           # spline order
nbasis <- 9
basis <- create.bspline.basis(rangeval=c(0,1600), nbasis=nbasis, norder=m)
plot(basis)
X_smoothed_f <- smooth.basis(argvals=time, y=X[1,], fdParobj=basis)
X_smoothed <- eval.fd(time, X_smoothed_f$fd)
X_smoothed1 <- eval.fd(time, X_smoothed_f$fd, Lfd = 1)
X_smoothed2 <- eval.fd(time, X_smoothed_f$fd, Lfd = 2)
x11()
x11()
par(mfrow=c(1,2))
plot(time, X[1,], type = "l", main = "Original datum", ylim= c(-250,250), ylab='')
plot(time, X_smoothed, type = "l", main = "Smoothed datum", ylim= c(-250,250),ylab='')
?smooth.basis
X_smoothed_f$penmat
X_smoothed_f$gcv
X_smoothed_f <- smooth.basis(argvals=time, y=X[1,], fdParobj=basis)
X_smoothed <- eval.fd(time, X_smoothed_f$fd)
load("data_extraction.RData")
# extract only one componet per patient
my_data = f.data$ausxSL
curves <- my_data$data
t_ax <- as.matrix(1:1600)
n <- dim(curves)[1]
# Cross validation for the choice of lambda ----------------------
nbasis <- 50
m <- 4
# generate a basis
basis <- create.bspline.basis(rangeval=range(t_ax),
nbasis = nbasis,
norder=m)
# grid of lambda
lambda <- 10^seq(-10,10)
gcv <- matrix(0,length(lambda),n)
for (i in 1:length(lambda))
{
print(i)
functionalPar = fdPar(fdobj=basis, Lfdobj=1, lambda=lambda[i])
gcv[i,] = smooth.basis(t_ax, t(curves), functionalPar)$gcv # see smooth.basis->argument y per il trasposto
}
# plot GCV for all the curves
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
# plot GCV for all the curves
x11()
matplot(log10(lambda), gcv, type = 'l', lwd=2, xlab="log10(lambda)", ylab="GCV error", main="GCV(lambda) error for different curves")
